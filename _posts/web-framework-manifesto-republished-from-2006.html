title: Web Framework Manifesto (republished from 2006)
date: 2011/07/06 12:00:35 -0700
tags: []
author: David Pollak
alias: /web-framework-manifesto-republished-from-2006

<div class="serendipity_entry_body"> <p style="margin-bottom: 0in;">[Originally posted to my now defunct blog on November 21, 2006]<br /></p><p style="margin-bottom: 0in;"><br /></p><p style="margin-bottom: 0in;"><br /></p><p style="margin-bottom: 0in;">After touring a whole bunch of web frameworks, I&#39;ve come to the conclusion that no existing framework satisfies the needs of a broad range of web developers. The existing web frameworks suffer from a wide variety of problems, conceptual and implementation-wise, that make way too much work for the web developer, the deployment guys, the folks who do application maintenance, and/or the end users. In this rant, I seek to define the criteria that a “good” web framework will meet.</p> </div> <div class="serendipity_entry_extended"> <p style="margin-bottom: 0in;">The criteria for a good web framework:</p> <ul><li><p style="margin-bottom: 0in;">A quick and easy way to map between a relational database and the target application. Rails&#39; ActiveRecord is a really great example of how to map a relational	 database. Sure, you might want to use Magma with Squeak for true object persistence, but for most applications in most of the world,	you&#39;ve got a relational database on the back end and you&#39;ve gotta 	map to it. The mapping should “do the right thing by default”	and all the schema and class information should live in 1 or at most 2 (e.g., migrations and model class) places.</p></li><li><p style="margin-bottom: 0in;">Easy, “right by default,” HTTP	 request mapping. A request comes in and gets routed to the right	place. This is another place that Rails really shines (at least at	the “page” level.) PHP and JSP also do well here. Schemes (like Struts) that require 35 configuration files, etc. to say	“/foo/bar/33” gets routed to the Bar method on the Foo	controller are way to complex. Seaside takes this to yet a better	level... requests get mapped to the right closure in the right	component. But I digress.</p></li><li><p style="margin-bottom: 0in;">Automatic “view” selection and 	 composition. Basically, the “right by default” view should be	selected based on the request, but alternate views should be	specified by the “controller.” Views should be CSS friendly. 	I&#39;m split over having separate template files (e.g., Rails, JSP, 	etc.) or embedding the HTML in the file (e.g., Seaside) or having	both options (Erlyweb.)</p></li></ul> <p style="margin-bottom: 0in;">So far, I&#39;ve described Rails. So far, I&#39;ve described a system that works well for knocking together quick “CRUD” (create, read, update, delete) applications. If all you ever needed to do was spit out web pages that allowed managing rows in a database, all you would need was Rails. But there&#39;s so much more that&#39;s necessary.</p> <ul><li><p style="margin-bottom: 0in;">Pages must be composed of 	 arbitrary components that manage their own state. This means that 	the search panel, the scrolling “what&#39;s hot” area, the catalog,	and the shopping cart are all separate components. Seaside really 	excels in this area. Check out the Seaside Sushi store demo that	demonstrates many different components with different state all on 	the same page. Remember also, that the component nature of the page	means that the components each receive their own UI messages. This 	is a place where Rails does not excel.</p></li><li><p style="margin-bottom: 0in;">The rendering of components must 	be asynchronous based on user-based and external event-based state 	change. This means that if state changes in the component, the UI	should be updated. Maybe it&#39;s updated the next time the page is 	reloaded (this is the way Seaside&#39;s Sushi store works,) the next	time there&#39;s an AJAX request made, or via a Comet push. The	components should be agnostic to the update mechanism. They should	merely mark themselves as dirty and be re-rendered the next time	there&#39;s an opportunity.</p></li><li><p style="margin-bottom: 0in;">Components should be live (or 	seamlessly persisted) at all times, ready to respond to events.</p></li><li><p style="margin-bottom: 0in;"> The browser should be honored and 	 feared. That means the back button should “do the right thing” 	(see Seaside) and input from the browser should never be trusted,	but should always be tested, validated, and destroyed if it is	unexpected (e.g., throw away a POST that contains parameters that	were not in the form presented to the user.)</p></li><li><p style="margin-bottom: 0in;">There should be a single way of 	 describing input validation. That validation should happen whenever	 possible on the client, but should always be repeated on the server	and before any model state is modified.</p>	</li><li><p style="margin-bottom: 0in;">Mapping between object fields and	 HTML (or whatever the presentation layer is) should be “right by	 default” and should be extensible based on new technology. Rails	and view helpers rule here.</p></li><li><p style="margin-bottom: 0in;">There should exist an orthogonal	 security layer such that objects that are not accessible to a user	 should never be returned in a query for the user and fields on an	object that are not accessible should not be visible. The security	and access control rules should be algebraic and demonstrable during	a security audit. This means that neither the view nor the	controller should have to test for access control. Objects and	requests should be sanitized before they get to the “controller.”</p></li><li><p style="margin-bottom: 0in;">Code should be impervious to a	replay attack. That means that fields in forms should have random	names that change for each request.</p></li><li><p style="margin-bottom: 0in;">There should exist a simple,	unified way to describe modal user behavior (e.g., filling out a	multi-page form.) Seaside rules in this respect.</p></li><li><p style="margin-bottom: 0in;">Sessions should be tied to a	browser window/tab, not to a browser session. Once again, Seaside	really rules on this count.</p></li><li><p style="margin-bottom: 0in;"> The framework and runtime should	correctly and gracefully deal with non-ASCII characters.</p>	</li><li><p style="margin-bottom: 0in;">Deploying the web application	should be as simple as putting a file in a known location (e.g., a	WAR file on a J2EE server) or by executing a single command (e.g.,	Capistrano.)</p></li><li><p style="margin-bottom: 0in;">Deployments should contain all	 dependencies such that as long as the target system meets a	particular minimum specification (e.g., running Java 1.4 and Tomcat	5.5), the application will work without having to load other 	configuration files.</p></li><li><p style="margin-bottom: 0in;">Deployment and management should	be able to be done via command line or a web browser and should	never require VNC or some other screen-cast or screen scraping.</p></li><li><p style="margin-bottom: 0in;">Testing should be an integral part	of the framework and should allow simulating HTTP requests. Rails	has the best testing framework of any web development framework I&#39;ve	seen.</p></li><li><p style="margin-bottom: 0in;">The production environment should	 support modern technology including executing multiple threads in a	 single process and allowing for many “live” objects to be	corresident (an absolute necessity for Comet-style applications.)</p></li><li><p style="margin-bottom: 0in;">The production environment should	 support hot code replacement such that new code can be placed in	 production without impairing existing user state.</p></li><li><p style="margin-bottom: 0in;">The development environment should	 support hot code replacement such that once a file is saved, it	becomes live at the next HTTP request. Sure, it may be compiled and	moved to the app server on save (Eclipse does this with Java code)	but the developer should not have to explicitly compile, restart,	reload in order to test a change.</p></li><li><p style="margin-bottom: 0in;">The system should be able to map input from a variety of different formats (SOAP, REST, SMTP, etc.) such that requests are normalized and responses are sent over the appropriate medium.</p></li><li><p style="margin-bottom: 0in;">There should exist a mechanism for adding functionality to the system with few or no API calls. Rails Engines are an example of this.</p></li><li><p style="margin-bottom: 0in;">Subsystems and added functionality should be defined by a clear interface that can be tested and validated during a compile or test cycle. Using parts of the subsystems that are not defined by the interface should be flagged during the test or compile cycle.</p></li></ul> <p style="margin-bottom: 0in;">That&#39;s the list so far. I think it&#39;s doable with existing technology.</p> <p style="margin-bottom: 0in;">Rails (<a href="http://web.archive.org/web/20070305161710/http://rubyonrails.com/">http://rubyonrails.com/</a>) is awesome for CRUD, but becomes as hard as Java/JSP beyond the basic paradigm.</p> <p style="margin-bottom: 0in;">Seaside (<a href="http://web.archive.org/web/20070305161710/http://seaside.st/">http://seaside.st/</a>) has the most innovative ideas and the best abstraction away from HTTP. However, Squeak as it currently exists and Cincom&#39;s pricing are barriers.</p> <p style="margin-bottom: 0in;">Erlyweb (<a href="http://web.archive.org/web/20070305161710/http://erlyweb.org/">http://erlyweb.org/</a>) an Erlang-based, Rails-inspired framework has the best chance to deal with high volume Comet-style applications. The Erlang run-time is stable and supports a huge (hundreds of thousands) number of concurrent threads and has an amazing message passing mechanism.</p> <p style="margin-bottom: 0in;">Jifty (<a href="http://web.archive.org/web/20070305161710/http://jifty.org/view/HomePage">http://jifty.org/view/HomePage</a>) is Rails on Perl... not a bad idea.</p> <p style="margin-bottom: 0in;">Django (<a href="http://web.archive.org/web/20070305161710/http://www.djangoproject.com/">http://www.djangoproject.com/</a>) is a Python-based framework. I haven&#39;t used it, but many people love it. I have been unable to wrap my head around Python. Given how many people use and like Python, this seems to be a failure in my brain. Sorry I can&#39;t give better feedback about a tool that others find value in.</p> <p style="margin-bottom: 0in;">Aranea (<a href="http://web.archive.org/web/20070305161710/http://www.araneaframework.org/">http://www.araneaframework.org/</a>) is a Java framework that barks up some of the same trees that Seaside does. However, without continuations (or at least syntactically pleasing continuations) I don&#39;t think a Java-based framework can support rapid, maintainable web sites.</p> </div>
