title: Scala Option, Lift Box and how to make your code better
date: 2010/06/01 15:39:00 -0700
tags: []
author: David Pollak
alias: /scala-option-lift-box-and-how-to-make-your-co

<div style="font-family: verdana, arial, helvetica, sans-serif;">Scala has a ton of nice features. One of the features that I was slow to adopt, until Burak Emir gently reminded me a bunch of times, is "Options". Read on about Options, Boxes, and how Lift makes good use of the to make clean, error resistant code.</div>
<div style="font-family: verdana, arial, helvetica, sans-serif;">
<a></a>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;">If you come from an imperative (Java, Ruby) background, you'll probably recognize the following code:</p>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;"><span style="font-family: courier new, courier, monospace;"> </span></p>
<code> <span style="font-family: courier new, monospace;">x = someOperation<br />  if !x.nil?<br />  y = someOtherOperation<br />  if !y.nil? doSomething(x,y)<br />    return "it worked"<br />  end <br />end <br />return "it failed"</span> </code>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;"> </p>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;">Okay, so that's pseudo-code, but there are tons of operation, guard, operation, guard, blah blah constructs.</p>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;">Further, null/nil are passed around as failures. This is especially bad when it's null, but it's pretty bad when it's nil because it's not clear to the consumer of the API that there can be a "call failed" return value.</p>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;">In Java, null is a non-object. It has no methods. It is the exception to the statically typed rule (null has no class, but any reference of any class can be set to null.) Invoking a method on null has one and only one result: an exception is thrown. null is often returned from methods as a flag indicating that the method ran successfully, but yielded no meaningful value. For example, CardHolder.findByCreditCardNumber("2222222222")  In fact, the guy who invented null called it a <a href="http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare" target="_blank">billion dollar mistake</a>.</p>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;">Ruby has nil which is marginally better than null. nil is a real, singleton object. There's only one instance of nil in the whole system. It has methods. It is a subclass of Object. Object has a method called "nil?" which returns false, except the nil singleton overrides this method to return true. nil is returned much like null in Java. It's the "no valid answer" answer.</p>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;">Scala does something different.</p>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;">There's an abstract class, called Option. Options are strongly typed. They are declared Option[T]. This means an Option can be of any type, but once its type is defined, it does not change. There are two subclasses of Option: Some and None. None is a singleton (like nil). Some is a container around the actual answer. So, you might have a method that looks like:</p>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;"><span style="font-family: courier new, courier, monospace;"> </span></p>
<span style="font-family: courier new, courier, monospace;"> <span style="font-family: courier new, monospace;">def findUser(name: String): Option[User] = {<br />  val query = buildQuery(name)<br />  val resultSet = performQuery(query)<br />  val retVal = if (resultSet.next) Some(createUser(resultSet)) else None <br />  resultSet.close<br />  retVal <br />}</span> </span>
<p style="margin-top: 0px; padding-bottom: 0px;"> </p>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;"><span style="font-family: courier new, courier, monospace;"> </span>Some, you've got a findUser method that returns either Some(User) or None. So far, it doesn't look a lot different than our example above. So, to confuse everyone, I'm going to talk about collections for a minute.</p>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;">A really nice thing in Scala (yes, Ruby has this too) is rich list operations. Rather than creating a counter and pulling list (array) elements out one by one, you write a little function and pass that function to the list. The list calls the function with each element and returns a new list with the values returned from each call. It's easier to see it in code:</p>
<p style="margin-top: 0px; padding-bottom: 0px;"><span style="font-family: courier new, monospace;">scala&gt; List(1,2,3).map(x =&gt; x * 2)<br />line0: scala.List[scala.Int] = List(2,4,6)</span></p>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;">The above code multiplies each list item by two and "map" returns the resulting list. Oh, and you can be more terse, if you want:</p>
<p style="margin-top: 0px; padding-bottom: 0px;"><span style="font-family: courier new, monospace;">scala&gt; List(1,2,3).map(_ * 2)<br /> line2: scala.List[scala.Int] = List(2,4,6)</span></p>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;">You can nest map operations:</p>
<p style="margin-top: 0px; padding-bottom: 0px;"><span style="font-family: courier new, monospace;">scala&gt; List(1,2,3).map(x =&gt; List(4,5,6).map(y =&gt; x * y))<br />line13: scala.List[scala.List[scala.Int]] = List(List(4,5,6),List(8,10,12),List(12,15,18))</span></p>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;">And, you can "flatten" the inner list:</p>
<p style="margin-top: 0px; padding-bottom: 0px;"><span style="font-family: courier new, monospace;">scala&gt; List(1,2,3).flatMap(x =&gt; List(4,5,6).map(y =&gt; x * y))<br /> line14: scala.List[scala.Int] = List(4,5,6,8,10,12,12,15,18)</span></p>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;">Finally, you can "filter" only the even numbers from the first list:</p>
<p style="margin-top: 0px; padding-bottom: 0px;"><span style="font-family: courier new, monospace;">scala&gt; List(1,2,3).filter(_ % 2 == 0).<br />       flatMap(x =&gt; List(4,5,6).map(y =&gt; x * y))<br />line16: scala.List[scala.Int] = List(8,10,12)</span></p>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;">But, as you can see, the map/flatMap/filter stuff gets pretty verbose. Scala introduced a "for" comprehension to make the code more readable:</p>
<code>scala&gt; for {x &lt;- List(1,2,3) if x % 2 == 0<br />            y &lt;- List(4,5,6)} yield x * y<br />res0: List[Int] = List(8, 10, 12)<br /> </code>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;"> </p>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;">Okay, but what does this have to do with Option[T]?</p>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;">Turns out that Option implements map, flatMap, and filter (the methods necessary for the Scala compiler to use in the 'for' comprehension). Just as a side note, when I first encountered the phrase "'for' comprehension", I got scared. I've been doing programming for years and never heard of a "comprenhension" let alone a 'for' one. Turns out, that there's nothing fancy going on, but "'for' comprehension" is just a term of art for the above construct.</p>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;">So, the cool thing is that you can use this construct very effectively. The first example is simple:</p>
<code>scala&gt; for {x &lt;- Some(3)<br />            y &lt;- Some(4)} yield x * y<br /> res1: Option[Int] = Some(12) </code>
<div> </div>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;">"That's nice, you just wrote a lot of code to multiply 3 by 4."</p>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;">Let's see what happens if we have a "None" in there:</p>
<code>scala&gt; val yOpt: Option[Int] = None <br />yOpt: Option[Int] = None <br /><br />scala&gt; for {x &lt;- Some(3)<br />            y &lt;- yOpt} yield x * y <br />res3: Option[Int] = None </code>
<div> </div>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;">So, we get a "None" back. How do we turn this into a default value?</p>
<code><span style="font-family: courier new, monospace;">scala&gt; (for {x &lt;- Some(3); y &lt;- yOpt} yield x * y) getOrElse -1 <br />res4: Int = -1</span></code> <br /><code><span style="font-family: courier new, monospace;"><br />scala&gt; (for {x &lt;- Some(3); y &lt;- Some(4)} yield x * y) getOrElse -1 <br />res5: Int = 12</span> </code>
<div> </div>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;">Note that the "getOrElse" code is "passed by name". Put another way, that code is only executed if the "else" clause is valid.</p>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;">Lift has an analogous construct called Box.</p>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;">A Box Full or not.  A non-Full Box can be the Empty singleton or a Failure.  A Failure carries around information about why the Box contains no value.</p>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;">Failure is very helpful because you can carry around information to display an error... an HTTP response code, a message, what have you.</p>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;">In Lift, I put this all together in the following way:</p>
<ul>
<li>methods that return request parameters return Box[String]</li>
<li>finder methods on models (not find all, just the ones that return a single instance) return Box[Model]</li>
<li>any method that would have returned a null if I was writing in Java returns a Box[T] in Lift</li>
</ul>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;">That means you get code that looks like:</p>
<span style=""><span style="font-family: courier new, monospace;">scala&gt; for {id &lt;- S.param("id") ?~ "id param missing"<br /> u &lt;- getUser(id) ?~ "User not found"<br /> } yield u.toXml <br />res6: net.liftweb.common.Box[scala.xml.Elem] = Failure(id param missing,Empty,Empty)</span></span><span style="font-family: courier new, monospace;"> </span>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;"><br />There's no explicit guard/test to see if the "id" parameter was passed in and there's no explicit test to see if the user was found.</p>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;">Note also that this code is completely type-safe. While there was no explicit type declarations, the compiler was able to figure out what types the various objects were.</p>
<p style="font-family: verdana, arial, helvetica, sans-serif; margin-top: 0px; padding-bottom: 0px;">So, let's look at the code inside a REST handler:</p>
<p style="margin-top: 0px; padding-bottom: 0px;"><span style="font-family: courier new, monospace;">  serve {<br /></span><span style="font-family: courier new, monospace;">    case "user" :: "info" :: _ XmlGet _ =&gt;<br /> </span><span style="font-family: courier new, monospace;">      for {<br /></span><span style="font-family: courier new, monospace;">        id &lt;- S.param("id") ?~ "id param missing" ~&gt; 401<br /> </span><span style="font-family: courier new, monospace;">        u &lt;- User.find(id) ?~ "User not found"<br /></span><span style="font-family: courier new, monospace;">      } yield u.toXml<br /> </span><span style="font-family: courier new, monospace;">  }</span></p>
<p style="margin-top: 0px; padding-bottom: 0px;">If the id parameter is missing, present a nice error message and return a 401 (okay... this is random, but you get the point).  And by default, if the user isn't found, return a 404 with the error that the user isn't found.</p>
<p style="margin-top: 0px; padding-bottom: 0px;">Here's what it looks like using wget:</p>
<p> </p>
<p style="margin-top: 0px; padding-bottom: 0px;"><span style="font-family: courier new, monospace;">dpp@bison:~/lift_sbt_prototype$ wget <a href="http://localhost:8080/user/info.xml" target="_blank">http://localhost:8080/user/info.xml</a><br /> </span><span style="font-family: courier new, monospace;">--2010-06-01 15:07:27--  <a href="http://localhost:8080/user/info.xml" target="_blank">http://localhost:8080/user/info.xml</a><br /></span><span style="font-family: courier new, monospace;">Resolving localhost... ::1, 127.0.0.1<br /> </span><span style="font-family: courier new, monospace;">Connecting to localhost|::1|:8080... connected.<br /></span><span style="font-family: courier new, monospace;">HTTP request sent, awaiting response... 401 Unauthorized<br /> </span><span style="font-family: courier new, monospace;">Authorization failed.<p />dpp@bison:~/lift_sbt_prototype$ wget <a href="http://localhost:8080/user/info.xml?id=2" target="_blank">http://localhost:8080/user/info.xml?id=2</a><br /> </span><span style="font-family: courier new, monospace;">--2010-06-01 15:07:44--  <a href="http://localhost:8080/user/info.xml?id=2" target="_blank">http://localhost:8080/user/info.xml?id=2</a><br /></span><span style="font-family: courier new, monospace;">Resolving localhost... ::1, 127.0.0.1<br /> </span><span style="font-family: courier new, monospace;">Connecting to localhost|::1|:8080... connected.<br /></span><span style="font-family: courier new, monospace;">HTTP request sent, awaiting response... 404 Not Found<br /> </span><span style="font-family: courier new, monospace;">2010-06-01 15:07:44 ERROR 404: Not Found.<p />dpp@bison:~/lift_sbt_prototype$ wget <a href="http://localhost:8080/user/info.xml?id=1" target="_blank">http://localhost:8080/user/info.xml?id=1</a><br /> </span><span style="font-family: courier new, monospace;">--2010-06-01 15:24:12--  <a href="http://localhost:8080/user/info.xml?id=1" target="_blank">http://localhost:8080/user/info.xml?id=1</a><br /></span><span style="font-family: courier new, monospace;">Resolving localhost... ::1, 127.0.0.1<br /> </span><span style="font-family: courier new, monospace;">Connecting to localhost|::1|:8080... connected.<br /></span><span style="font-family: courier new, monospace;">HTTP request sent, awaiting response... 200 OK<br /> </span><span style="font-family: courier new, monospace;">Length: 274 [text/xml]<br /></span><span style="font-family: courier new, monospace;">Saving to: `info.xml?id=1'<br /> </span><span style="font-family: courier new, monospace;"><br />dpp@bison:~/lift_sbt_prototype$ cat info.xml\?id\=1 <br /></span><span style="font-family: courier new, monospace;">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br /> </span><span style="font-family: courier new, monospace;">&lt;User id="1" firstName="Elwood" ... validated="true" superUser="false"&gt;&lt;/User&gt; </span></p>
<p style="margin-top: 0px; padding-bottom: 0px;">One more thing about Box and Option... they lead to less complex, more maintainable code.  Even if you didn't know anything about Scala or Lift, you can read the XML serving code and the console exchange and figure out what happened any <strong>why</strong> it happened.  This is a lot more readable than deeply nested if statements. And if it's readable, it's maintainable.</p>
<p style="margin-top: 0px; padding-bottom: 0px;">I hope this is an understandable introduction to Scala's Option class and 'for' comprehension and how Lift makes use of these tools.</p>
</div>

