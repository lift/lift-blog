title: Lift and Data Driven Comet
date: 2011/07/07 15:05:19 -0700
tags: []
author: David Pollak
alias: /lift-and-data-driven-comet

Daniel Spiewak is one a rant again about Lift&#39;s Comet model being the wrong one and being the devil and such.  He&#39;s had this rant in the past and I&#39;ve tried to talk him through the positive of what he does want.  I&#39;ve been unable to understand why his goal isn&#39;t served by what&#39;s already in Lift&#39;s Comet support.  What the discussion usually boils down to is &quot;in most of the Lift Comet examples, the server manipulates client DOM, but the server should know/care about client state.&quot;  I agree with that, but the fact that example code manipulates client DOM doesn&#39;t mean that this is the only way to work with Lift&#39;s Comet.  Further, complaining about the examples rather than discussing positive use cases doesn&#39;t help me or the Lift team better understand how to build better data-driven (rather than DOM driven) examples and abstractions.  With that off my chest, let me walk through Lift&#39;s Comet and how one can build data driven Comet apps based on available examples as well as some conceptual discussions about what I&#39;ve done in non-open source projects.<p /> <br /> Let&#39;s take a quick tour of Comet and what Lift&#39;s Comet implementation offers.  HTTP is a client-owned protocol.  The client in HTTP makes a request on a server.  Based on that request, the server returns a response.  After the server has returned the response, the server has no further mechanism for changing state on the client.<p /> <br />It&#39;s valuable to have applications that allow server state to be &quot;pushed&quot; to the client.  These applications include stock quote applications, sports betting, multi-user games, etc.  Comet, or server push, is a mechanism for the browser to keep an HTTP connection open to the server and when server state changes in a way that may impact the client, the server sends data over the connection to the client and the client processes the chunk of data.<p /> <br />There are a fair number of &quot;elegant engineering solutions&quot; to keeping the HTTP connection open so that the server can &quot;push&quot; new information to the client.  <p /><br />Lift&#39;s current Comet implementation uses long polling.  In the future, Lift will also use WebSockets, but the WebSocket API and implementation isn&#39;t &quot;baked&quot; yet, and Lift&#39;s current implementation works well for browsers from IE6 on.  Lift&#39;s long polling implementation opens a single HTTP connection from the browser to the server if one or more Comet components are detected on a HTML page.  The request contains a list of the components and the &quot;version&quot; for each of the components.  If the version number of any of the components on the server is &quot;newer&quot; than the version on the client, the deltas are sent as the response, the connect is closed, the browser applies the deltas and then re-opens the HTTP connection (with HTTP 1.1 keep-alive this does not imply reopening a TCP/IP connection.)  If the version of the component changes while the HTTP &quot;poll&quot; is open, the deltas are sent down as a response and the connection is closed.  If no state changes after 110 seconds (this is a tunable parameter), a noop is sent to the browser and the browser re-opens the HTTP connection.  The 110 second timeout is to insure that Lift&#39;s comet implementation is proxy friendly.<p /> <br />Lift&#39;s comet implementation is hidden from the developer.  The developer need only focus on two things:<br /><ol><li>Generating &quot;initial state&quot; that is sent from the server to the browser during a full page load that contains a Comet component</li> <li>When state changes on the server (state can only change for the CometActor is it receives an asynchronous message in its Actor mailbox), the server generates JavaScript that causes the browser to take appropriate action based on the server state change.  Not all state changes on the server necessarily result in state changes on the client.  Further, this does not imply that the server must keep track of or keep a mirror of client state.</li> </ol><br />The mechanism for achieving #1 above is implementing the <span style="font-family: courier new,monospace;">render</span> and <span style="font-family: courier new,monospace;">fixedRender</span> methods in a CometActor.  The former is required and the latter is optional.  The combination of the return values of these two methods define initial state for the CometActor during a full page load.  Here&#39;s the documentation for <span style="font-family: courier new,monospace;">render</span>:<br /> <div style="margin-left: 40px;"><span style="font-family: courier new,monospace;">  /**</span><br style="font-family: courier new,monospace;" /><span style="font-family: courier new,monospace;">   * It&#39;s the main method to override, to define what is rendered by the CometActor</span><br style="font-family: courier new,monospace;" /> <span style="font-family: courier new,monospace;">   *</span><br style="font-family: courier new,monospace;" /><span style="font-family: courier new,monospace;">   * There are implicit conversions for a bunch of stuff to</span><br style="font-family: courier new,monospace;" /> <span style="font-family: courier new,monospace;">   * RenderOut (including NodeSeq).  Thus, if you don&#39;t declare the return</span><br style="font-family: courier new,monospace;" /><span style="font-family: courier new,monospace;">   * turn to be something other than RenderOut and return something that&#39;s</span><br style="font-family: courier new,monospace;" /> <span style="font-family: courier new,monospace;">   * coersable into RenderOut, the compiler &quot;does the right thing&quot;(tm) for you.</span><br style="font-family: courier new,monospace;" /><span style="font-family: courier new,monospace;">   * &lt;br/&gt;</span><br style="font-family: courier new,monospace;" /> <span style="font-family: courier new,monospace;">   * There are implicit conversions for NodeSeq, so you can return a pile of</span><br style="font-family: courier new,monospace;" /><span style="font-family: courier new,monospace;">   * XML right here.  There&#39;s an implicit conversion for NodeSeq =&gt; NodeSeq,</span><br style="font-family: courier new,monospace;" /> <span style="font-family: courier new,monospace;">   * so you can return a function (e.g., a CssBindFunc) that will convert</span><br style="font-family: courier new,monospace;" /><span style="font-family: courier new,monospace;">   * the defaultHtml to the correct output.  There&#39;s an implicit conversion</span><br style="font-family: courier new,monospace;" /> <span style="font-family: courier new,monospace;">   * from JsCmd, so you can return a pile of JavaScript that&#39;ll be shipped</span><br style="font-family: courier new,monospace;" /><span style="font-family: courier new,monospace;">   * to the browser.</span><br style="font-family: courier new,monospace;" /> <span style="font-family: courier new,monospace;">   */</span><br style="font-family: courier new,monospace;" /><span style="font-family: courier new,monospace;">  def render: RenderOut</span><br style="font-family: courier new,monospace;" /> </div><p />You can define your render method to be DOM oriented.  Here&#39;s the super duper simple code for a Comet-based Chat app where the Server defines the DOM:<br /><div class="container" style="margin-left: 40px;"> <div class="line number1 index0 alt2"><code class="scala comments">/**</code></div><div class="line number2 index1 alt1"><code class="scala spaces"> </code><code class="scala comments">* The comet chat component</code></div> <div class="line number3 index2 alt2"><code class="scala spaces"> </code><code class="scala comments">*/</code></div><div class="line number4 index3 alt1"><code class="scala keyword">class</code> <code class="scala plain">Chat </code><code class="scala keyword">extends</code> <code class="scala plain">CometActor </code><code class="scala keyword">with</code> <code class="scala plain">CometListener {</code></div> <div class="line number5 index4 alt2"><code class="scala spaces">  </code><code class="scala keyword">private</code> <code class="scala keyword">var</code> <code class="scala plain">msgs</code><code class="scala keyword">:</code> <code class="scala plain">Vector[String] </code><code class="scala keyword">=</code> <code class="scala plain">Vector() </code><code class="scala comments">// private state</code></div> <div class="line number6 index5 alt1"> </div><div class="line number7 index6 alt2"><code class="scala spaces">  </code><code class="scala comments">// register this component</code></div><div class="line number8 index7 alt1"> <code class="scala spaces">  </code><code class="scala keyword">def</code> <code class="scala plain">registerWith </code><code class="scala keyword">=</code> <code class="scala plain">ChatServer</code></div><div class="line number9 index8 alt2">  </div><div class="line number10 index9 alt1"><code class="scala spaces">  </code><code class="scala comments">// listen for messages</code></div><div class="line number11 index10 alt2"><code class="scala spaces">  </code><code class="scala keyword">override</code> <code class="scala keyword">def</code> <code class="scala plain">lowPriority </code><code class="scala keyword">=</code> <code class="scala plain">{</code></div> <div class="line number12 index11 alt1"><code class="scala spaces">    </code><code class="scala keyword">case</code> <code class="scala plain">v</code><code class="scala keyword">:</code> <code class="scala plain">Vector[String] </code><code class="scala keyword">=</code><code class="scala plain">&gt; msgs </code><code class="scala keyword">=</code> <code class="scala plain">v; reRender()</code></div> <div class="line number13 index12 alt2"><code class="scala spaces">  </code><code class="scala plain">}</code></div><div class="line number14 index13 alt1"> </div><div class="line number15 index14 alt2"><code class="scala spaces">  </code><code class="scala comments">// render the component</code></div> <div class="line number16 index15 alt1"><code class="scala spaces">  </code><code class="scala keyword">def</code> <code class="scala plain">render </code><code class="scala keyword">= </code><code class="scala plain"></code><code class="scala string">&quot;li *&quot;</code> <code class="scala keyword">#</code><code class="scala plain">&gt; msgs</code></div> <div class="line number17 index16 alt2"><code class="scala plain">}</code></div></div><p />This example demonstrates how easy it is to write a Lift Comet component.  It is not and full, industrial strength implementation of a Chat component.  It is an example that strips the code down to its bear essence.  The essence is &quot;set up default state, when change comes in, change complete state and redraw the entire screen real estate associated with the component to reflect the new state.&quot;<p /> <br />However, we could just as easily have done an entirely data driven application.  This is taken from the <a href="https://github.com/dpp/Frothy/blob/master/src/main/scala/com/liftcode/comet/Clock.scala">Frothy</a> example that integrates Lift and Cappuccino:<br /> <div class="CodeRay">
  <div class="code"><pre>class Clock extends CometActor {   override def localSetup() {     super.localSetup()     ActorPing.schedule(this, 'Ping , 3 seconds)   }  override def highPriority = {     case 'Ping =&gt;      partialUpdate(currentTime)       ActorPing.schedule(this, 'Ping , 3 seconds)   }  def currentTime: JsCmd = JsRaw(&quot;clockCallback(&quot;+(&quot;&quot;+now).encJs+&quot;);&quot;)   def render = {     val str: String = &quot;&quot;&quot;var f = function() {try {&quot;&quot;&quot;+(currentTime.toJsCmd)+&quot;&quot;&quot;} catch (e) {setTimeout(f, 50);}}; f();&quot;&quot;&quot;     OnLoad(JsRaw(str))   }}</pre></div>
</div>
<br />In this example, the server side knows nothing about the client state.  The server side sends events to the client and those events call a client side function with event data.  The server-side knows nothing about the client state, browser DOM or anything else.  It&#39;s up to the client side to implement the the function.<p /> <br />More generically, the above could be written as:<p /><div style="margin-left: 40px;">class KnowNothing extends CometActor {<br />  def render = Noop // we have no comment on initial component state<p />   override def lowPriority = {<br />    case msg: MyMessage =&gt; partialUpdate(callEventHandler(jsonSerialize(msg)))<br />  }<p />  def callEventHandler(in: JObject): JsCmd = // what function do we call on the client side with a JSON blob?<br />   def jsonSerialize(in: MyMessage): JObject = // serialize a case class<br />}<br /></div><p />And voila... we&#39;ve got a comet component that simply passes events from the server to the client.  The Comet component has no knowledge or information about client state.  This is in effect an &quot;Actor proxy&quot; between the server and the client.  What you get is an implementation that passes messages from server to client.<p /> <br />&quot;What benefit do I get by using the event passing mechanism?&quot; you may ask.  Lift&#39;s Comet implementation multiplexes all the Comet components on a page through a single HTTP connection.  So, you could have 20 or 50 or more event handlers in the browser all handling different parts of the screen and Lift will handle all those components through a single connection.  If there are 10 updates between HTTP requests, all those updates will go down the same response.  If the client is disconnected for a period of time (a mobile user is on a train going through a tunnel where there&#39;s no Internet connectivity), the client will receive all the deltas in order when the client is once again reconnected (note there are certain limits that are tunable as to the amount of time and aggregate number per comet component of deltas that are retained.)<p /> <br />So, we&#39;ve shown both ends of the &quot;server knows everything about client state&quot; and &quot;server knows nothing about client state&quot; spectrum.<p /><br />I&#39;ve written substantial Lift comet code for <a href="http://innovationgames.com/innovation-games-online/">Innovation Games</a> and <a href="http://much4.us/much4/">Much4</a>.<p /> <br />In Much4, the CometActor in the server kept the authoritative copy of the data.  When updates can in the data deltas were calculated and JavaScript that updated the client&#39;s representation of the data to match the server&#39;s version of the data was sent to the client via partialUpdate along with a command to &quot;redraw&quot; the client.  The client redrawing was accomplished entirely in JavaScript on the client... the updated DOM was generated entirely by client-side JavaScript.  Thus, the state that the server knew about the client was the state of the data on the client.  The CometActor on the server knew nothing about the DOM state on the client.<p /> <br />In the Buy a Feature game in Innovation Games, the CometActor on the server kept a copy of the DOM of the gameboard.  The server was authoritative about the client&#39;s data state and DOM state.  In fact, the client kept no state other than the DOM.  Changes to gameboard state were calculated by generating deltas between state and time T and state at time T+1 and those changes were turned into DOM manipulation JavaScript that was aggregated and send to the client via partialUpdate.  Because of the rules of gameplay, there was never a case where the places that the user was changing on the gameboard would be updated without the server knowing the deltas.<p /> <br />In the Prune the Product Tree game, the gameplay took place on an SVG canvas for &quot;modern&quot; browsers and some wacky something something in IE6.  The server never had any knowledge about the way that the gameboard was being displayed.  In this instance, we kept with the gameboard delta mechanism, but the deltaing generated two pieces of JavaScript for each delta between gameboard at T and gameboard at T+1.  One of those deltas was the JavaScript necessary to update the browser-side data structure at that point in the node and the second was a call into the node-specific &quot;update the visual display&quot; routine (for example <span style="font-family: courier new,monospace;">moveItem(itemID, oldPosX, oldPosY, newPosX, newPosY)</span>).  In this case, the deltaing routine had to have knowledge of the API structure on the client.  This was for expediency sake... it was easier to write Scala code that knew about the client APIs than write JavaScript that could take the delta commands and also forward them to the redrawing commands.  In this case, the server knew what client data state should be and generated commands to send the data down.  Note, too, that the client was &quot;smart enough&quot; not to cause data changes if (1) the the browser already contained the new state (this allowed for a single client to update its state without having to do a server round-trip) and (2) not updating items that the user was &quot;touching&quot; until the user finished touching the item.<p /> <br />Lift&#39;s Comet support has been able to work effectively with the above wide range of scenarios.  The place where Lift&#39;s Comet support will not work as well is if you try to mix the metaphors of DOM state and data state when there&#39;s code in the browser that will modify the DOM state without telling the server.  In the case that you only want the server to be partially knowledgeable about DOM state, then you&#39;re opening a huge can of worms.  Yes, Lift lets you open that can of worms, but just because a web framework lets you make bad design decisions that&#39;s not the web framework&#39;s fault.<p /> <br />Yes, there are plenty of API improvements we could make for data-driven Lift Comet.  I&#39;d love to see a data diffing mechanism that&#39;d take two JObjects and come out with JavaScript representing the commands needed to update the old to the new as well as generate the delta events.  We hand-wrote that mechanism in Prune the Product Tree... but having it automagic would be great.  Yep, it&#39;d be better if there was more documentation and example code for doing data-driven Comet.  I&#39;d love to get beyond the research phase on my Lift Comet to KnockoutJS integration as well as finishing the work I started doing Lift to SproutCore integration.  But a lot of that kind of stuff is community and client demand driven.<p /> <br />So, I thoroughly and completely disagree with the assertion that Lift&#39;s comet support requires that you keep state or DOM state in the Comet component.  Lift&#39;s Comet support gives the developer a wide variety of ways to send a wide variety of data from the server to the client based on events on the server.
